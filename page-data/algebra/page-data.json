{"componentChunkName":"component---src-templates-section-js","path":"/algebra","result":{"data":{"mdx":{"slug":"18.703-abstract-algebra/theorems","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"a + a + a + ... + a = n cdot a, n in mathbb{Z}, a in R\"], [\"a + a + a + ... + a = n \\\\cdot a, n \\\\in \\\\mathbb{Z}, a \\\\in R\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Definitions and theorems in abstract algebra\",\n  \"date\": \"2020-07-21\",\n  \"slug\": \"algebra\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Box = makeShortcode(\"Box\");\nvar M = makeShortcode(\"M\");\nvar BlockMath = makeShortcode(\"BlockMath\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Definitions and theorems in abstract algebra\"), mdx(Box, {\n    type: \"Definition\",\n    number: 4.1,\n    author: \"Fraleigh\",\n    mdxType: \"Box\"\n  }, mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"group\"), \" is a set \", mdx(M, {\n    mdxType: \"M\"\n  }, \"G\"), \", \", mdx(\"u\", null, \"closed under a binary operation\"), \" \", mdx(M, {\n    mdxType: \"M\"\n  }, \"*\"), \", such that three axioms are satisfied:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"G1. (Associative)\"), \" For all \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a, b, c \\\\in G\"), \", we have\")), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"(a * b) * c = a * (b * c)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"G2. (Identity)\"), \" There is an element \", mdx(M, {\n    mdxType: \"M\"\n  }, \"e \\\\in G\"), \" such that for all \", mdx(M, {\n    mdxType: \"M\"\n  }, \"x \\\\in G\"), \", \")), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"e * x = x * e = x\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"G3. (Inverse)\"), \" For each \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a \\\\in G\"), \", there is a corresponding element \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a' \\\\in G\"), \" such that\")), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"a * a' = a' * a = e\")), mdx(Box, {\n    type: \"Definition\",\n    number: 18.1,\n    author: \"Fraleigh\",\n    mdxType: \"Box\"\n  }, mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ring\"), \" \", mdx(M, {\n    mdxType: \"M\"\n  }, \" \\\\langle R, +, \\\\cdot \\\\rangle\"), \" is a set \", mdx(M, {\n    mdxType: \"M\"\n  }, \"R\"), \" with two binary operations \", mdx(M, {\n    mdxType: \"M\"\n  }, \"+\"), \" and \", mdx(M, {\n    mdxType: \"M\"\n  }, \"\\\\cdot\"), \", which we call \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"addition\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"multiplication\"), \", defined on \", mdx(M, {\n    mdxType: \"M\"\n  }, \"R\"), \" such that the following axioms are satisfied:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"R1. (Addition is abelian)\"), \" \", mdx(M, {\n    mdxType: \"M\"\n  }, \"\\\\langle R, +\\\\rangle\"), \" is an abelian group.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"R2. (Associative)\"), \" Multiplication is associative.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"R3. (Distributive)\"), \" For all \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a, b, c \\\\in R\"), \", the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"left distributive law\"), \" \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a(b + c) = (ab) + (ac)\"), \" \", \"\\xA0\", \"and \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"right distributive law\"), \" \", mdx(M, {\n    mdxType: \"M\"\n  }, \"(a + b)c = (ac) + (bc)\"), \"\\xA0\", \" hold.\")), mdx(\"br\", null), mdx(\"p\", null, \"Because we denote \", mdx(M, {\n    mdxType: \"M\"\n  }, \"n\"), \" repeated sums as \", mdx(M, {\n    math: String.raw(_templateObject()),\n    mdxType: \"M\"\n  }), \" when refering to multiplication within the ring, we use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"juxtaposition notation\"), \" \", mdx(M, {\n    mdxType: \"M\"\n  }, \"ab\"), \" in lieu of \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a \\\\cdot b\"), \".\"), mdx(\"p\", null, \"We use \", mdx(M, {\n    mdxType: \"M\"\n  }, \"0\"), \" to denote the additive identity of the ring, and \", mdx(M, {\n    mdxType: \"M\"\n  }, \"-a\"), \" to denote the additive inverse of \", mdx(M, {\n    mdxType: \"M\"\n  }, \"a\"), \".\")), mdx(Box, {\n    type: \"Theorem\",\n    number: 18.8,\n    author: \"Fraleigh\",\n    mdxType: \"Box\"\n  }, mdx(\"p\", null, \"If \", mdx(M, {\n    mdxType: \"M\"\n  }, \"R\"), \" is a ring with additive identity \", mdx(M, {\n    mdxType: \"M\"\n  }, \"0\"), \", then \", mdx(M, {\n    mdxType: \"M\"\n  }, \"\\\\forall a, b \\\\in R\"), \" we have:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(M, {\n    mdxType: \"M\"\n  }, \"0a = a0 = 0\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(M, {\n    mdxType: \"M\"\n  }, \"a(-b) = (-a)b = -(ab)\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(M, {\n    mdxType: \"M\"\n  }, \"(-a)(-b) = ab\"))), mdx(\"br\", null), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Proof.\"), \" In order to prove properties about multiplication, we're going to need to use the distributive law, since that is the only tool afforded to us by the definition of a ring.\"), mdx(\"p\", null, \"For Property 1, by axioms \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"R1\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"R2\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TODO\"))), mdx(Box, {\n    type: \"Definition\",\n    number: 18.14,\n    author: \"Fraleigh\",\n    mdxType: \"Box\"\n  }, mdx(\"p\", null, \"A ring in which the \", mdx(\"u\", null, \"multiplication\"), \" is commutative is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"commutative ring.\"), \" A ring with a \", mdx(\"u\", null, \"multiplicative\"), \" identity element is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ring with unity\"), \"; the multiplicative identity element \", mdx(M, {\n    math: \"1\",\n    mdxType: \"M\"\n  }), \" is called \", \"\\u201C\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"unity\"), \"\\u201D\", \".\")), mdx(Box, {\n    type: \"Definition\",\n    comment: \"Fields and Units\",\n    number: 18.16,\n    author: \"Fraleigh\",\n    mdxType: \"Box\"\n  }, mdx(\"p\", null, \"Let \", mdx(M, {\n    math: \"R\",\n    mdxType: \"M\"\n  }), \" be a ring with unity \", mdx(M, {\n    math: \"1 \\\\ne 0\",\n    mdxType: \"M\"\n  }), \". An element \", mdx(M, {\n    math: \"u \\\\in R\",\n    mdxType: \"M\"\n  }), \" is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"unit\"), \" of \", mdx(M, {\n    math: \"R\",\n    mdxType: \"M\"\n  }), \" if it has a multiplicative inverse in \", mdx(M, {\n    mdxType: \"M\"\n  }, \"R\"), \". If every \", mdx(\"u\", null, \"nonzero\"), \" element of \", mdx(M, {\n    mdxType: \"M\"\n  }, \"R\"), \" is a unit, the \", mdx(M, {\n    mdxType: \"M\"\n  }, \"R\"), \" is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"division ring\"), \" (or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"skew field\"), \"). A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"field\"), \" is a \", mdx(\"u\", null, \"commutative\"), \" division ring. \"), mdx(\"p\", null, \"A field has the obeys the following:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(M, {\n    math: \"\\\\langle F, + \\\\rangle\",\n    mdxType: \"M\"\n  }), \" is an abelian group with identity \", mdx(M, {\n    math: \"0\",\n    mdxType: \"M\"\n  }), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(M, {\n    math: \"\\\\langle F \\\\setminus \\\\{0\\\\}, \\\\cdot \\\\rangle\",\n    mdxType: \"M\"\n  }), \" is an abelian group with identity \", mdx(M, {\n    math: \"1 \\\\ne 0\",\n    mdxType: \"M\"\n  }), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Both the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"left distributive law\"), \" and \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"right distributive law\"), \" hold.\"))), mdx(Box, {\n    type: \"Note\",\n    comment: \"Zero ring\",\n    mdxType: \"Box\"\n  }, mdx(\"p\", null, \"The only ring \", mdx(M, {\n    math: \"R\",\n    mdxType: \"M\"\n  }), \" with \", mdx(M, {\n    math: \"1 = 0\",\n    mdxType: \"M\"\n  }), \" is the zero ring of one element \", mdx(M, {\n    math: \"\\\\{ 0 \\\\}\",\n    mdxType: \"M\"\n  }), \".\"), mdx(\"p\", null, \"Source: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Ring_(mathematics)#Basic_properties\"\n  }), \"https://en.wikipedia.org/wiki/Ring_(mathematics)#Basic_properties\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Definitions and theorems in abstract algebra","slug":"algebra"}}},"pageContext":{"slug":"18.703-abstract-algebra/theorems"}}}